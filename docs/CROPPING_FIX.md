# 🔧 修复帧裁切过度问题

## 问题描述

根据 `cut.png` 截图显示的问题：
- ❌ 提取的帧只显示中间部分，左右两侧被裁切掉
- ❌ 黑色分隔线被误识别为第9帧
- ❌ old.jpg 应该只有8帧，却检测到9帧

## 根本原因

1. **过度裁切** - 初始裁切参数太激进（18%-82%），导致画面两侧被切掉
2. **内容边界检测过于激进** - 亮度阈值太高，将有效内容误判为黑边
3. **分隔线未过滤** - 最小帧高度阈值太低，将分隔线识别为帧

## 解决方案

### 1. 放宽初始裁切范围

**修改前**:
```python
# 在 extract_frames() 中
rough_crop_left = int(width * 0.18)   # 裁掉18%
rough_crop_right = int(width * 0.82)  # 裁掉18%
```

**修改后**:
```python
# 只裁掉齿孔区域，保留更多内容
rough_crop_left = int(width * 0.08)   # 只裁掉8%
rough_crop_right = int(width * 0.92)  # 只裁掉8%
```

**效果**: 宽度保留率从 64% 提升到 84%

---

### 2. 降低内容边界检测阈值

**修改前**:
```python
# 在 detect_content_boundaries() 中
if mean_brightness < 50:
    threshold = max_brightness * 0.10
else:
    threshold = max_brightness * 0.15
```

**修改后**:
```python
# 更保守的阈值，避免误判内容为黑边
if mean_brightness < 30:
    threshold = max_brightness * 0.05   # 很暗的图像
elif mean_brightness < 60:
    threshold = max_brightness * 0.08   # 中等亮度
else:
    threshold = max_brightness * 0.12   # 明亮图像
```

**效果**: 减少将有效内容误判为黑边

---

### 3. 增加内容边界Padding

**修改前**:
```python
top = max(0, i - 2)      # 2px padding
bottom = min(height, i + 3)  # 3px padding
```

**修改后**:
```python
top = max(0, i - 3)      # 3px padding
bottom = min(height, i + 4)  # 4px padding
```

**效果**: 保留更多边缘内容

---

### 4. 添加过度裁切保护

**新增代码**:
```python
# 确保不会裁切掉超过40%的内容
height_ratio = (bottom - top) / height
width_ratio = (right - left) / width

if height_ratio < 0.6:
    # 裁切太多，使用完整高度
    top = 0
    bottom = height

if width_ratio < 0.6:
    # 裁切太多，使用完整宽度
    left = 0
    right = width
```

**效果**: 防止极端情况下的过度裁切

---

### 5. 提高最小帧高度以过滤分隔线

**修改前**:
```python
min_frame_height = 20  # 固定20px
```

**修改后**:
```python
# 最小帧高度应该至少是图像高度的8%或40px
min_frame_height = max(int(height * 0.08), 40)
```

**效果**: 有效过滤黑色分隔线，避免被误识别为帧

---

### 6. 增加最终帧尺寸验证

**新增代码**:
```python
# 最终帧至少应该是粗裁帧的20%
if final_height > rough_frame.shape[0] * 0.2 and \
   final_width > rough_frame.shape[1] * 0.2:
    frames.append(final_frame)
else:
    # 内容检测太激进，使用粗裁帧
    frames.append(rough_frame)
```

**效果**: 防止内容检测过于激进导致帧太小

---

## 测试结果

### old.jpg 测试 (365x800)

| 项目 | 修复前 | 修复后 |
|------|--------|--------|
| 检测帧数 | 9帧 (含分隔线) | ✅ 8帧 (正确) |
| 平均帧宽 | ~150px (41%) | ✅ 242px (66%) |
| 画面完整性 | ❌ 左右被切 | ✅ 完整显示 |
| 分隔线过滤 | ❌ 未过滤 | ✅ 已过滤 |

### 所有Demo图片测试 (9张)

| 文件 | 图片尺寸 | 帧数 | 平均帧尺寸 | 宽度保留率 |
|------|----------|------|------------|------------|
| 1.jpg | 1080x1598 | 4 | 907x377 | 84.0% |
| 2.jpg | 1080x1598 | 6 | 907x242 | 84.0% |
| 3.jpg | 1080x1598 | 5 | 907x301 | 84.0% |
| 4.jpg | 1080x1598 | 5 | 906x291 | 83.9% |
| 5.jpg | 1080x1598 | 8 | 907x174 | 84.0% |
| 6.jpg | 1080x1598 | 5 | 907x301 | 84.0% |
| 7.jpg | 1080x1598 | 8 | 897x181 | 83.0% |
| 8.jpg | 1080x3648 | 8 | 907x382 | 84.0% |
| old.jpg | 365x800 | 8 | 242x90 | 66.3% |

**统计**:
- ✅ 平均帧数: 6.3 (合理范围)
- ✅ 平均宽度保留率: 81.9%
- ✅ 无过度检测问题
- ✅ 所有帧画面完整

---

## 改进效果对比

### 帧完整性

**修复前** (cut.png 截图):
```
┌──────────────────┐
│   ████████████   │  ← 只显示中间部分
│   画面被裁切    │  ← 左右两侧缺失
└──────────────────┘
```

**修复后**:
```
┌────────────────────────┐
│ █████████████████████  │  ← 显示完整画面
│   保留左右完整内容    │  ← 仅去除齿孔
└────────────────────────┘
```

### 帧数准确性

**修复前**:
- demo图片: 16-21帧 (严重过度检测)
- old.jpg: 9帧 (含分隔线)

**修复后**:
- demo图片: 4-8帧 (准确)
- old.jpg: 8帧 (准确)

---

## 技术细节

### 裁切流程

1. **粗裁切** (去除齿孔)
   - 左侧: 8%
   - 右侧: 92%
   - 保留: 84%宽度

2. **内容边界检测** (去除黑边)
   - 亮度阈值: 5%-12% (根据图像亮度)
   - Padding: 3-4px
   - 最小保留: 60%尺寸

3. **尺寸验证**
   - 最终帧 ≥ 粗裁帧的20%
   - 帧高度 ≥ 图像高度的8%或40px

### 关键参数调整

| 参数 | 修复前 | 修复后 | 说明 |
|------|--------|--------|------|
| 初始裁切左 | 18% | 8% | 保留更多内容 |
| 初始裁切右 | 82% | 92% | 保留更多内容 |
| 亮度阈值 | 10%-15% | 5%-12% | 更保守 |
| 边界Padding | 2-3px | 3-4px | 更多缓冲 |
| 最小帧高 | 20px | 8%或40px | 过滤分隔线 |
| 最小保留率 | 无 | 60% | 防止过度裁切 |

---

## 使用建议

### 1. 正常胶片处理
- ✅ 直接使用默认设置
- ✅ 自动检测和裁切效果良好
- ✅ 保留完整画面内容

### 2. 特殊情况
如果遇到帧不完整的情况:
1. 检查原始胶片图片质量
2. 确保分隔线清晰可见
3. 检查是否有严重曝光问题

### 3. 手动调整
如需要更精确控制:
- 可以在GUI中手动删除误识别的帧
- 可以调整FPS来改变视频速度
- 保留的帧会按顺序生成视频

---

## 验证方法

### 1. 运行自动测试
```bash
source venv/bin/activate
python3 test_cropping.py        # 测试old.jpg
python3 test_all_demo.py        # 测试所有demo图片
```

### 2. GUI测试
```bash
./run_gui.sh
```

**测试步骤**:
1. 添加 demo/old.jpg
2. 点击"提取所有帧"
3. 检查是否显示8帧（不是9帧）
4. 查看帧预览，确认画面完整
5. 生成视频并播放检查

### 3. 视觉检查
查看提取的帧图片:
```
test_output/old_frames/frame_01.jpg
test_output/old_frames/frame_02.jpg
...
```

确认:
- ✅ 左右两侧没有被裁切
- ✅ 主要内容完整可见
- ✅ 只有齿孔区域被去除

---

## 文件修改

### lomokino_processor.py

**修改的函数**:
1. `extract_frames()` - 行215-268
   - 调整初始裁切范围 (8%-92%)
   - 提高最小帧高度阈值
   - 添加最终帧尺寸验证

2. `detect_content_boundaries()` - 行131-213
   - 降低亮度检测阈值 (5%-12%)
   - 增加边界padding (3-4px)
   - 添加过度裁切保护 (60%最小保留)

---

## 总结

✅ **解决了三个关键问题**:
1. 帧画面不完整（左右被切）→ 放宽裁切范围
2. 分隔线被误识别为帧 → 提高最小帧高度
3. 内容边界检测过激 → 降低亮度阈值 + 添加保护

✅ **改进效果**:
- 宽度保留率: 64% → 82%
- 帧数准确性: 16-21帧 → 4-8帧
- 画面完整性: 部分 → 完整

✅ **适用所有demo图片**:
- 9张测试图片全部通过
- 无过度检测问题
- 帧画面完整清晰

---

**现在可以正常使用了！** 🎬✨
